// MazeSolver  //Initialize Pins    // H-Bridge Pinsint ena = 3;        // Changed - make sure to change the wiringint in4 = 2;        // Changed - make sure to change the wiringint in3 = 4;int in1 = 5;int in2 = 7;        // Changed - make sure to change the wiringint enb = 6;        // Changed - make sure to change the wiring    // RangeFinder Pinsint echoF = 8;int triggerF = 9;int echoR = 10;int triggerR = 11;int echoL = 12;int triggerL = 13;// Constantsint OBSTACLE_CLOSE_UPP = -1;int OBSTACLE_CLOSE_LOW = -1;int OBSTACLE_CLOSE = 3;#define LEFT 3#define RIGHT 2#define STRAIGHT 1#define TURN_TIME_RIGHT 270     // How long to turn 90 degrees. Will need to be calibrated for each team#define TURN_TIME_LEFT 375// Initialize variablesfloat straightDistance = 0, rightDistance = 0, leftDistance = 0;void setup() {      // Sets the pins as input pins or output pins, according to role  pinMode(2, OUTPUT);  pinMode(3, OUTPUT);  pinMode(4, OUTPUT);  pinMode(5, OUTPUT);  pinMode(6, OUTPUT);  pinMode(7, OUTPUT);  pinMode(triggerF, OUTPUT);  pinMode(echoF, INPUT);  pinMode(triggerR, OUTPUT);  pinMode(echoR, INPUT);  pinMode(triggerL, OUTPUT);  pinMode(echoL, INPUT);  Serial.begin(9600); // Sets the baud rate  delay(3000);}// Will work, but doesn't actually guarantee a solved maze as it is right nowvoid loop() {    straightDistance = GetDistance(STRAIGHT);  rightDistance = GetDistance(RIGHT);  leftDistance = GetDistance(LEFT);  if (straightDistance < OBSTACLE_CLOSE){    analogWrite(ena, 0);  }  else {    digitalWrite(in1, LOW);    digitalWrite(in2, HIGH);    analogWrite(enb, 200);    analogWrite(ena, 200);  }  if (straightDistance < OBSTACLE_CLOSE_UPP && straightDistance > OBSTACLE_CLOSE_LOW) {  // if (straightDistance < OBSTACLE_CLOSE) {    Stop();    delay(300);    Backward();    delay(110);    rightDistance = GetDistance(RIGHT);    leftDistance = GetDistance(LEFT);    Stop();    delay(500);        if (leftDistance > rightDistance) {      LeftTurn90();      //delay(1000);    }    else if (rightDistance > leftDistance) {      RightTurn90();      //delay(1000);    }    else if (rightDistance == leftDistance) {      Backward();      delay(75);    }    Stop();    delay(300);    Stop();  }  else {    GoStraight();  }    OBSTACLE_CLOSE_UPP = 12;  OBSTACLE_CLOSE_LOW = 2;}void Stop() {  analogWrite(enb, 0);  analogWrite(ena, 0);  return;}void GoStraight() {    // Sets all wheels to forward     -    these may need to be changed  digitalWrite(in1, LOW);  digitalWrite(in2, HIGH);  digitalWrite(in3, HIGH);  digitalWrite(in4, LOW);  analogWrite(enb, 200);  analogWrite(ena, 200);        // PWM to slow down the maze solver   /*for (int i = 0; i < 10; i++) {    analogWrite(enb, 150);    analogWrite(ena, 100);    delay(200);    analogWrite(enb, 0);    analogWrite(ena, 0);    delay(100);  }*/  return;}void Backward() {  digitalWrite(in1, HIGH);  digitalWrite(in2, LOW);  digitalWrite(in3, LOW);  digitalWrite(in4, HIGH);  analogWrite(enb, 155);  analogWrite(ena, 110);}void LeftTurn90() {      // Sets right wheel to forward  digitalWrite(in1, HIGH);  digitalWrite(in2, LOW);  analogWrite(ena, 180);  digitalWrite(in3, HIGH);  digitalWrite(in4, LOW);  analogWrite(enb, 180);    // Continues for enough time to turn 90 degrees. TURN_TIME (top of file) will need to be adjusted   delay(TURN_TIME_LEFT);     return;}void RightTurn90() {    // Sets left wheel to forward  digitalWrite(in1, LOW);  digitalWrite(in2, HIGH);  analogWrite(ena, 170);  digitalWrite(in3, LOW);  digitalWrite(in4, HIGH);  analogWrite(enb, 170);    // Continues for enough time to turn 90 degrees. TURN_TIME (top of file) will need to be adjusted  delay(TURN_TIME_RIGHT);  return;}double GetDistance(int directions) {  double duration, distance;  if (directions == STRAIGHT) {      // Sequence to activate the rangeFinders and read the data    digitalWrite(triggerF, LOW);    delayMicroseconds(2);    digitalWrite(triggerF, HIGH);    delayMicroseconds(10);    duration = pulseIn(echoF, HIGH);    distance = (duration / 2) * 0.0343; // Converts from m/s to cm/us    distance = round(distance);    Serial.println("distance1 =  ");    Serial.println(distance);  }  // } else if (directions == RIGHT) {  //     // Sequence to activate the rangeFinders and read the data  //   digitalWrite(triggerR, LOW);  //   delayMicroseconds(2);  //   digitalWrite(triggerR, HIGH);  //   delayMicroseconds(10);  //   duration = pulseIn(echoR, HIGH);  //   distance = (duration / 2) * 0.0343; // Converts from m/s to cm/us  //   distance = round(distance);  //   Serial.println("distance2 =  ");  //   Serial.println(distance);  // } else if (directions == LEFT) {  //     // Sequence to activate the rangeFinders and read the data  //   digitalWrite(triggerL, LOW);  //   delayMicroseconds(2);  //   digitalWrite(triggerL, HIGH);  //   delayMicroseconds(10);  //   duration = pulseIn(echoL, HIGH);  //   distance = (duration / 2) * 0.0343; // Converts from m/s to cm/us      //   Serial.println("distance3 =  ");  //   Serial.println(distance);  // }  return distance;}